# 들어가며...
각 서비스별로 의존성이 있는 경우 (공통모듈서비스와 이에 의존하는 서비스들, 혹은 MSA와 같이 서로의 기능을 호출하는 구조)

당장의 실시간 정보를 가져올 수 있는 동기적인 연동을 하게 된다.

참고) 동기적인 연동과 비동기적인 연동
```
A 서비스 → B 서비스에 HTTP 요청
         ↳ B 서비스가 응답할 때까지 A 서비스는 대기함

```

```
A 서비스 → 메시지 큐(Kafka, RabbitMQ 등)에 요청 데이터 전송
         ↳ B 서비스는 큐에서 메시지를 소비함
         ↳ A는 응답을 기다리지 않고 바로 다음 작업 진행

```
동기적인 연동은 당장의 실시간 정보를 가져올 수 있다는 장점이 있지만, 서비스간에 강력한 의존 관계가 생기고
쉽게 장애 전파가 된다.

만약, 비동기적으로 연동이 된다면 직접적인 장애 전파를 막을 수 있지만,
실시간성 처리나 비동기 처리를 위한 코드 복잡도 상승 등의 이유로 비동기 전환이 어려울 수 있다.

따라서 서킷 브레이커는 동기 상황에서 장애 전파를 위해 필요하다.


# 서킷 브레이커란?
누전차단기, 회로차단기, 주식 시장에서 흔히 볼 수 있는 용어로 

과열된 회로를 차단하거나 주가 변동으로 인한 시장 붕괴를 막기위한 거래를 중단하는 장치/제도를 일컫는다.

다들 장애 전파를 막는데에 목적을 두고 있다.

SW에서 말하는 서킷 브레이커는 서로 다른 시스템 간의 연동 시, 장애 전파 차단을 목적으로 한다.
연동 시 이상을 감지하고, 이상이 발생하면 연동을 차단하고, 이후 이상이 회복하면 자동으로 다시 연동하기 위한 기술이다.

서킷 브레이커는 상태에 따라 서로 다른 동작을 하는데, 

3가지의 보통 상태(OPEN, CLOSED, HALF_OPEN)와 2가지의 특별한 상태(DISABLED, FORCE_OPEN)을 갖는다.
보통 상태엔
- OPEN/HALF_OPEN : 문제 발생이 감지됨
- CLOSED : 정상적으로 호출되고 응답을 줌

특별한 상태엔
- DISBLED : 항상 호출을 허용
- FORCE_OPEN : 항상 호출을 거부
- 

서킷브레이커는 슬라이딩 윈도(sliding window)를 사용하여 상태의 변화여부를 결정한다.

슬라이딩 윈도는 횟수 방식(COUNT_BASED)과 시간 방식(TIME_BASED)으로 나뉜다.
방식에 따라 슬라이딩 윈도 안에서 정해진 확률보다 높은 확률로 호출에 실패하게 되면 상태를 OPEN으로 변경한다.
OPEN 상태에서는 연동된 시스템 호출을 시도하지 않으며, 
바로 호출 실패 Exception을 발생시키거나 정해진 fallback 동작을 수행한다.

OPEN 이후 설정한 시간이 지나면 HALF_OPEN 상태로 변경되며, 
호출이 정상화되었는지 다시한번 실패 확률로 확인합니다. 정상화되었다고 판단되면, 
CLOSED 상태로 변경되며, 아직 정상화되지 못했다고 판단되면 다시 OPEN 상태로 되돌아 간다.
<img width="479" alt="image" src="https://github.com/user-attachments/assets/9e113226-5638-4ae1-911a-652046903fde" />

# Resilience4j
애플리케이션 레벨에서 서킷브레이크 구현에는 Resilience4j를 사용한다.
Resilience4j는 Netflix Hystrix로부터 영감을 받은 함수형 프로그래밍으로 설계된, 경량의 내결함성 라이브러리이다.

함수형 프로그래밍으로 설계가 되어서 functional interface, lambda, method reference 등을 활용하여 구현이 가능하다.
원래 Spring Cloud에서는 Spring Cloud Hystrix를 서킷 브레이커로 사용했으나, 
현재는 maintenence 모드로 전환되었고, 대체 모듈로 Resilience4j가 선택되었다.
참고로, Resilience4j는 Rate Limiter, Retry, Bulkhead, TimeLimiter, Cache등을 수행할 수 있다.



