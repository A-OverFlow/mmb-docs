# **동시성 이슈(Concurrency Issue)**

둘 이상의 실행 흐름(스레드·프로세스·컨테이너·서버리스 함수·다른 마이크로서비스 등)이 시간을 겹쳐 하나의 공유 자원에 접근‧수정할 때, 실행 순서가 예측 불가하게 뒤섞이면서 데이터
정합성·성능·가용성에 이상 현상을 일으키는 모든 문제를 통칭합니다.

## 핵심 개념

- 복수의 실행 흐름
    - 같은 JVM 안의 스레드일 수도 있고, 서로 다른 노드에 띄운 마이크로서비스 인스턴스일 수도 있습니다.
- 공유 자원
    - 데이터베이스 행‧테이블, 캐시 키, 파일, 네트워크 소켓, 메시지 큐 오프셋 등.
- 인터리빙(Interleaving)
    - CPU가 시분할 방식으로 작업을 교차 실행하기 때문에, 논리적으로 “동시에” 보이지만 실제로는 명령어 단위로 순서가 섞입니다.
- 비결정성
    - 같은 코드라도 실행 시점의 스케줄링·네트워크 지연·락 경쟁 상태에 따라 결과가 달라질 수 있습니다.

# 자주 발생하는 동시성 이슈 순위

## 1. Idempotency(멱등성) 결여로 인한 중복 실행 🔥

* **개념**
    * 동일 요청이 두 번 이상 도착했을 때 결과가 한 번 처리한 것과 완전히 같아야 한다는 성질이 보장되지 않아, 데이터가 중복 반영되는 문제입니다.
* **예시**
    * 모바일 앱에서 결제 버튼을 두 번 탭 → 결제 승인 두 건 생성
    * HTTP 502 후 클라이언트가 자동 재시도 → 주문 API가 두 번 호출
    * Kafka 오프셋 커밋이 지연돼 같은 메시지가 다시 소비 → 재고 두 번 차감

## 2. Lost Update / Race Condition 🔥

* **개념**
    * 두 개 이상의 트랜잭션이 같은 데이터(특히 같은 행)를 거의 동시에 수정하면서, 마지막에 커밋된 값이 앞선 변경을 덮어써 버리는 현상입니다.
* **예시**
    * 플래시 세일 중 두 사용자가 동시에 재고-1 요청 → 최종 재고가 1만 감소해야 하지만 2 감소
    * 포인트 적립 로직이 멀티 스레드로 동시에 실행 → 일부 적립 내역이 사라짐

## 3. 데이터베이스 Deadlock

* **개념**
    * 트랜잭션 A와 B가 서로 상대가 보유한 락을 기다리며 영원히 풀리지 않는 상태입니다.
* **예시**
    * 트랜잭션 A: 주문 테이블 → 적립금 테이블 순으로 업데이트
    * 트랜잭션 B: 적립금 테이블 → 주문 테이블 순으로 업데이트
      → 두 트랜잭션이 서로를 기다리며 교착

## 4. Thundering Herd / Cache Stampede

* **개념**
    * 캐시 TTL이 동시에 만료되면서 많은 인스턴스가 한꺼번에 원본 데이터베이스나 외부 API를 호출해 폭주가 일어나는 현상입니다.
* **예시**
    * 자정 0시에 전 제품 가격 캐시가 만료 → 수천 개 애플리케이션 인스턴스가 동시에 DB 조회
    * 인기 게시물 목록 캐시가 10초마다 만료 → 트래픽 피크 시 DB CPU 100 %

## 5. 분산 정합성(Exactly-Once, Saga·보상 트랜잭션)

* **개념**
    * 여러 마이크로서비스가 각자 데이터베이스를 가질 때, 단일 사업 행위를 여러 단계로 나누어도 최종적으로 일관된 상태를 유지해야 한다는 과제입니다.
* **예시**
    * 결제 서비스는 성공·주문 서비스는 실패 → 고객에게 돈은 빠져나갔지만 주문이 없음
    * 배송 상태 이벤트가 중복 전파 → 사용자 화면에 배송 단계가 뒤죽박죽

## 6. 격리 수준 관련 이상(Dirty/Non-repeatable/Phantom Read)

* **개념**
    * 낮은 트랜잭션 격리 수준에서 발생하는 읽기 불일치 현상으로, 읽은 데이터가 다른 트랜잭션에 의해 변경·삽입되어 동일 쿼리라도 결과가 달라지는 문제입니다.
* **예시**
    * 보고서 생성 중 합계가 단계마다 달라져 최종 합계와 상세 수치가 불일치
    * 통계 배치 작업이 진행되는 동안 실시간 API가 중간 상태 데이터를 노출

## 7. Starvation(기아)·Livelock(라이브락)

* **개념**
    * 특정 스레드·트랜잭션이 계속해서 자원을 얻지 못하거나, 락을 얻었다 놓았다만 반복해 실제 작업이 진행되지 않는 상태입니다.
* **예시**
    * CPU-바운드 배치 작업이 스레드 풀 대부분을 점유 → 실시간 API 응답 지연
    * 공정하지 않은 락 구현으로 특정 스레드가 영원히 대기

# Idempotency(멱등성) 보장

## 1. Idempotency 보장 방법 정리

1. **클라이언트 (UI·SDK) 레벨**

  * **한 번 클릭 후 버튼 비활성화·로딩 스피너 표시**
  * 요청을 보낼 때마다 **UUID·ULID 등으로 Idempotency-Key를 생성**하고,
    동일 행위 재시도 시에는 같은 키를 재사용(로컬 스토리지·세션 스토리지 활용)
  * 지수 백오프(+ Jitter) 재시도 로직을 공통 SDK에 내장

2. **API 게이트웨이 / 애플리케이션 입구** 🔥

  * `Idempotency-Key` 헤더가 없으면 400 Bad Request
  * Redis `SETNX`(또는 RDB UNIQUE)로 **“첫 요청만 통과”**
  * 성공 응답을 짧은 TTL(5 – 15 분)로 캐싱 후 **같은 키 재요청에는 그대로 반환**

3. **도메인 모델 · 데이터베이스**

  * `request_id`(또는 `idempotency_key`) 컬럼에 **UNIQUE 제약** + UPSERT
  * JPA `@Version`·CAS로 Lost Update 방지(중복 write 자체 예방)

4. **메시지 큐 · 이벤트 흐름**

  * **Kafka Transactional Producer** ( `enable.idempotence=true` )
  * **Outbox → CDC** 패턴: 이벤트 저장과 MQ 전송을 원자적으로 묶고, 컨슈머는 `event_id` 중복 검사

5. **관측 · 운영**

  * `idempotency_hit_total`, `duplicate_ratio`, Kafka `record_lag` 등 지표 수집
  * 키 TTL 분포·메모리 사용량 모니터링, 중복 히트 급증 시 UI·네트워크·서버 오류 교차 점검

---

## 2. 가장 효과적인 해결책: **API 입구 Idempotency-Key 필터**

### 2-1. 효과가 가장 큰 이유

1. **범용 차단** – 모바일 더블 탭, 브라우저 재전송, 게이트웨이 재시도, MQ 중복 호출 등 “중복이 만들어지는 모든 경로”를 **가장 앞단**에서 한 번에 막습니다.
2. **언어·플랫폼 독립** – 백엔드 로직·DB 스키마·메시지 브로커를 건드리지 않고도 즉시 적용 가능.
3. **비용 대비 이득 극대** – Redis `SETNX` 한 줄로 실질적 데이터 손상을 90 % 이상 차단할 수 있고, 운영 지표까지 바로 확보됩니다.
4. **추가 안전망과 충돌 없음** – DB UNIQUE 제약·Outbox를 그대로 유지하면서 “첫 방어선” 역할을 합니다.

### 2-2. 핵심 구현 포인트(요약)

```java
// 필수 헤더 검사
String key = req.getHeader("Idempotency-Key");
if (key == null || key.isBlank()) { res.sendError(400, "Idempotency-Key required"); return; }

// 첫 요청인지 확인
boolean first = Boolean.TRUE.equals(redis.opsForValue()
        .setIfAbsent("idem:" + key, "LOCK", Duration.ofMinutes(10)));

if (!first) {                       // 이미 처리된 행위
    String body = redis.opsForValue().get("idem:resp:" + key); // 캐시된 응답
    res.setStatus(200);
    res.getWriter().write(body == null ? "" : body);
    return;
}

// 실제 비즈니스 로직 실행 후
if (res.getStatus() / 100 == 2) {   // 성공
    redis.opsForValue().set("idem:resp:" + key, responseBody, Duration.ofHours(1));
    redis.expire("idem:" + key, Duration.ofHours(1));
} else {                            // 실패 → 키 삭제, 재시도 허용
    redis.delete("idem:" + key);
}
```

* **키 생성 위치** : 글쓰기·주문·결제 폼을 열 때 생성 → 같은 행위에 대한 모든 재시도에서 동일 키 사용
* **TTL** : “재시도 허용 시간 + α” (보통 5 – 15 분)
* **응답 전략** : 중복 요청에는 200 OK + 최초 응답 그대로 반환 → UX 자연스럽게 유지
* **지표** : `duplicate_hit_total` 증가율로 UI 실수·네트워크 오류·서버 5xx 원인 분석