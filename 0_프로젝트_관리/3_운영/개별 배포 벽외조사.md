![image](https://github.com/user-attachments/assets/093c4ff0-e0e9-4902-9a3e-73eb8329e42c)

이것저것 조사한.. 뽀꼬교 조사병단 벽 외 조사 기록

내일 조사 더 할 예정 ㄷㄷ


# 1. 각 마이크로서비스를 독립적으로 배포하려면?
한 서비스만 수정해도, 다른 서비스에 영향 없이 배포할 수 있어야 하는게 독립 배포입니도.

한 서비스에 변경이 생겼다고 해서 나머지 서비스가 함께 빌드되거나 배포되면 그건 MSA 철학을 위반하는 것 ㄷ

- 각 서비스는 별도의 DockerFile과 별도의 Docker-compose.yml 파일을 가집니다.
  - dockerfile은 서비스의 빌드 방식과 실행 환경을 정의한 것이기 때문에 공통된 DockerFile을 쓸 수 업뜸
  - 공통 docker-compose.yml 에 모든 서비스를 다 넣으면 docker-compose up 할 때 전체 서비스가 함께 실행되어 벌임
    - 특정 서비스만 개발하거나 배포하려는 상황에서는 불편하고, 변경이 없어도 다른 서비스까지 빌드/재시작 될 수 있음
      
- 각 서비스 디렉토리에서 개별적으로 다음 명령으로 배포합니다.

  ```bash
  # service-a 만 개별 빌드되고 실행하는 명령어
  docker-compose -f service-a/docker-compose.yml up -d --build
  ```

- CI/CD에서는 Git 머지 트리거를 통해 특정 서비스만 빌드 & 배포 할 수 있게 작업합니다.


# 2. 로컬 개발 방법
## 2-1. 로컬에선 어떻게?
코드 수정, 즉시 재실행, 브레이크포인트 디버깅, 로그 추적이 쉽다보니 IntelliJ(프로세스)로 실행하는 게 개발엔 편리하다 합니다.

✅ MSA 개발의 일반적인 흐름 (실무 기준)

💻 1. 개발자는 본인 서비스만 직접 실행 (IntelliJ에서 프로세스로)
- 빠른 피드백, 디버깅 용이
- 변경이 많은 핵심 로직 개발에 집중

🧱 2. 다른 서비스와 인프라는 docker-compose로 띄움
- 공통 리소스(Kafka, Redis, DB 등)는 항상 컨테이너로
- 다른 서비스들도 도커 이미지로 실행 (운영 환경과 유사)

🧪 3. 전체 서비스 통합 테스트가 필요할 땐 전체 컨테이너로 실행
- docker-compose -f all-in-one.yml up 같은 식으로 전체 실행
- 실제 요청 흐름, 연동 로직, 외부 API 호출 등 점검

따라서 아래의 워크플로우를 가져가는게 어떨지.
```
# 1. 공통 리소스 실행
docker-compose -f infra/docker-compose.yml up -d

# 2. 선택) 다른 서비스 도커로 실행
docker-compose -f service-b/docker-compose.yml up -d
docker-compose -f service-c/docker-compose.yml up -d


# 3. IntelliJ 에서 service-a 직접 실행
```

전체 띄우기
```
docker-compose \
  -f docker-compose.common.yml \
  -f service-a/docker-compose.yml \
  -f service-b/docker-compose.yml \
  -f service-c/docker-compose.yml \
  up -d

```


**그럼에도 불구하고, 컨테이너로도 실행할 때는?**
1. 로컬 환경과 배포 환경이 비슷한지 확인하고 싶을 때
2. 통합 테스트 또는 CI 환경과 동일하게 테스트하고 싶을 때

위 상황을 제외하고는 평상시엔 IntelliJ 실행을 기본으로 가져가쟈

### 요약
| 항목 | 추천 방식 |
|------|------------|
| 본인이 개발하는 마이크로서비스 | IntelliJ 등에서 프로세스로 실행 |
| 의존 서비스(DB, Kafka 등) | docker-compose로 컨테이너 실행 |
| 전체 서비스 통합 테스트 | 전체를 컨테이너로 실행 |

## 2-2. 전체 서비스 띄우기
본인이 개발하는 마이크로 서비스 이외에도 전체 시스템 흐름을 확인하고 싶을 경우...


## 2-3. IntelliJ 에서 Docker 사용 방법

!도커 설치 되어 있어야 함

step1. Settings > Build, Execution, Deployment > Docker

step2. + 버튼을 눌러 Docker for Mac, Docker for Windows, TCP Socket 중 환경에 맞게 설정

step3. 설정 후 Services 탭에서 컨테이너 상태, 로그 실행 관리 가능

step4. 각 서비스의 Dockerfile이나 docker-compose.yml 을 우클릭하여 실행 가능


# 3. 각 서비스별 docker-compose.yml 이 갖춰야할 내용
```yaml
version: '3.8'

services:
  service-a:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    env_file:
      - .env
    networks:
      - shared-network

```
최소 구성 : 
- build : 서비스 디렉토리와 Dockerfile 경로
- ports : 외부 포트 매핑
- env_file : 환경 변수 관리
- networks : 네트워크 설정


# 4. 공통 docker-compose.yml?
전체 msa 아키텍처를 구성하기 위해 개별 서비스가 가지는 docker compose 항목 외에 필요한 항목을 포함합니다.

디렉토리 구조
```bash
/msa-root/
  docker-compose.yml         <-- 공통 리소스 정의
  /service-a/
    docker-compose.yml
  /service-b/
    docker-compose.yml

```

MySql, Kafka, Redis 같은 의존 리소스에 대해 정의합니다.
| 이유 | 설명 |
|------|------|
| ❌ 로컬 설치 불편 | 각각 버전도 다르고, 설정도 다르고 귀찮음 |
| ✅ 컨테이너로 통일 | 공통 docker-compose.yml로 한번에 실행 가능 |
| 🧪 테스트 환경 통일 | 팀원 모두 같은 환경에서 개발 가능 |


```yaml
version: '3.8'

services:
  mmb-redis:
    image:  redis:latest
    ports:
      - 6379:6379

networks:
  shared-network:

```
각 서비스는 external_networks 설정으로 이 네트워크에 참여




# 5. 환경 변수 관리법
하나의 환경 변수 파일 또는 설정을 공유해서 둘다 같은 설정을 쓰게 만들어야 함
1. 로컬 레포에 있는 docker-compose.yml에 아래처럼 .env 파일을 불러오게 설정
```yaml
env_file:
  - .env
```
2. IntelliJ의 Run/Debug Configurations에 .env와 환경변수를 동일하게 입력
