# 개요

> MSA 환경에 서비스(프로젝트)가 배포될 수 있도록 설정하는 방법을 명시한다.

## 가이드가 필요한 이유

1. 서비스 단위 개발 및 배포는 MSA의 핵심이다
2. 서비스 개발자와 배포 담당자 모두 해당 과정을 이해하고 있어야 원활한 배포가 가능하다
3. MSA 환경에 서비스가 자동으로 배포될 때 거치는 과정이 복잡하다
4. 따라서, 모든 서비스(프로젝트)에 일관된 배포 설정이 필요하다

# 전체 흐름

1. 로컬 (개발자 환경)
    1. 서비스 개발
    2. 테스트
        1. 테스트 코드 작성 및 실행
        2. 프로세스 실행하여 테스트
            1. application-local.yml -> 로컬 환경에 맞게 모든 값 하드코딩
        3. 컨테이너로 실행하여 테스트
            1. docker-compose.yml
            2. .env -> 키만 존재하고 값은 없음. local 환경에 맞게 설정하여 사용.
    3. 통합 테스트 -> 필수는 아니지만 필요한 경우 가능해야 함
        1. 전체 프로세스 실행하여 테스트
        2. 전체 컨테이너 실행하여 테스트
    4. dev 브랜치에 push (PR)
2. 깃허브 (빌드서버)
    1. 도커 이미지 빌드 및 Docker Hub에 push
    2. 깃허브 액션 단계에서 깃허브 시크릿 참조하여 .env 생성
    3. docker-compose.yml + .env → 서버 전송
3. 개발 (개발 서버)
    1. 공통 설정과 함께 도커 컴포즈 실행
    2. 배포 완료
4. 운영 (운영 서버)
    1. dev 브랜치 prod 브랜치로 merge
    2. (이후 개발 서버와 같은 절차로 운영 서버에 배포)

# 상세 구조

## 서비스 저장소 (예: mmb-member-service)

```plaintext
mmb-member-service/
├── application.yml             ← 공통 설정
├── application-local.yml       ← 로컬 설정
├── application-dev.yml         ← 개발 설정
├── Dockerfile
├── docker-compose.yml          ← 네트워크 설정 없음
├── .env                        ← 로컬 전용, 값은 없고 키만 있음. ex) NAME=
└── .github/
    └── workflows/
        └── deploy-dev.yml      ← 서버 배포용 GitHub Actions 설정 파일
```

### ex) application.yml

```yaml
spring:
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
    database-platform: org.hibernate.dialect.MySQL8Dialect

logging:
  level:
    org.springframework: INFO
    com.example.member: DEBUG
```

- 공통 설정

### ex) application-local.yml

```yaml
spring:
  profiles:
    active: local

  datasource:
    url: jdbc:mysql://localhost:3306/member_db
    username: root
    password: localpass
    driver-class-name: com.mysql.cj.jdbc.Driver

server:
  port: 8080
```

- 로컬 개발용, 값 직접 설정
- 개발자는 별도 `.env` 없이도 바로 실행 가능
- `localhost` 기반 DB 연결 (원하는 환경으로 설정)

### ex) application-dev.yml

```yaml
spring:
  profiles:
    active: dev

  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    driver-class-name: com.mysql.cj.jdbc.Driver

server:
  port: ${PORT}
```

- 개발 서버용, 환경 변수 주입 기반
- `.env` → `docker-compose.yml` → Spring 환경 변수 전달
- 유연하게 환경에 따라 실행

### ex) docker-compose.yml

```yaml
version: "3.8"

services:
  member-service:
    image: your-id/mmb-member-service:${SPRING_PROFILE}
    ports:
      - "${PORT}:8080"
    env_file:
      - .env
    environment:
      - SPRING_PROFILES_ACTIVE=${SPRING_PROFILE}
      - DB_URL=jdbc:mysql://member-db:3306/member_db
      - DB_USERNAME=${DB_USERNAME}
      - DB_PASSWORD=${DB_PASSWORD}
    depends_on:
      - member-db

  member-db:
    image: mysql:8
    container_name: member-db
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_DATABASE: member_db
    ports:
      - "${DB_PORT}:3306"
    volumes:
      - ${DB_VOLUME_PATH}:/var/lib/mysql
```

- 로컬에선 `default` 네트워크 자동 연결
- 서버에선 공통 컴포즈 파일 사용하여 서비스 컴포즈 파일과 네트워크 설정을 병합

### ex) .env

```plaintext
SPRING_PROFILE=
PORT=
SPRING_PROFILE=
DB_USERNAME=
DB_PASSWORD=
DB_PORT=
DB_VOLUME_PATH=
```

- 키만 존재하고 값은 없는 스켈레톤 형태
- 필요한 환경 변수 목록을 명시적으로 확인할 수 있음
- 로컬에서는 해당 값을 채우고 docker compose 실행하여 테스트할 수 있음
- 값을 채운 상태로 커밋하지 않음 (스켈레톤 형태 유지)

### ex) .github/workflows/deploy-dev.yml

```yaml
name: Deploy to Dev Server

on:
  push:
    branches: [ dev ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      IMAGE_NAME: your-dockerhub-id/mmb-member-service
      TAG: dev

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ env.IMAGE_NAME }}:${{ env.TAG }}

      - name: Generate .env file from secrets
        run: |
          echo "IMAGE=${{ env.IMAGE_NAME }}:${{ env.TAG }}" > .env
          echo "PORT=8082" >> .env
          echo "SPRING_PROFILE=dev" >> .env
          echo "DB_URL=${{ secrets.DB_URL }}" >> .env
          echo "DB_USERNAME=${{ secrets.DB_USERNAME }}" >> .env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
          echo "NETWORK_NAME=msa-net" >> .env

      - name: Upload docker-compose.yml and .env to Dev Server
        uses: appleboy/scp-action@v0.1.3
        with:
          host: ${{ secrets.DEV_SSH_HOST }}
          username: ${{ secrets.DEV_SSH_USER }}
          key: ${{ secrets.DEV_SSH_PRIVATE_KEY }}
          source: "docker-compose.yml,.env"
          target: "~/msa-deploy/mmb-member-service"

      - name: Deploy on Dev Server
        uses: appleboy/ssh-action@v0.1.8
        with:
          host: ${{ secrets.DEV_SSH_HOST }}
          username: ${{ secrets.DEV_SSH_USER }}
          key: ${{ secrets.DEV_SSH_PRIVATE_KEY }}
          script: |
            cd ~/msa-deploy/mmb-member-service
            docker compose \
              -f ../docker-compose.common.yml \
              -f docker-compose.yml \
              --env-file .env \
              up -d

```

- 깃허브 시크릿을 참조하여 개발 서버에서 사용할 `.env` 파일 생성
- 서비스(프로젝트)에 존재하는 `docker-compose.yml` 파일을 개발 서버로 복사
- 개발 서버에 존재하는 `docker-compose.common.yml` 파일과 병합하여 서비스 실행

## 개발 서버

```plaintext
~/msa-deploy/
├── docker-compose.common.yml     ← 공통 네트워크 정의 + 서비스 네트워크 설정
├── mmb-member-service/               ← 서비스 별로 디렉토리 생성됨
│   ├── docker-compose.yml        ← 서비스(프로젝트)에서 복사해온 파일
│   └── .env                      ← GitHub Actions에서 GitHub Secret 참조하여 생성
├── mmb-frontend/
│   └── ...
└── scripts/                      ← 전체 서비스 실행 및 종료 스크립트
    ├── start-all.sh
    └── stop-all.sh
```

### ex) docker-compose.common.yml

```yaml
version: "3.8"

services:
  mmb-member-service:
    networks:
      - msa-net

  mmb-auth-service:
    networks:
      - msa-net

networks:
  msa-net:
    driver: bridge
```

- 공통 네트워크 정의 및 서비스 네트워크 설정
- 서비스는 이름만 맞추면 병합 시 자동 연결됨

# 서비스(컨테이너) 실행 방법

## 로컬 (개발자용)

```bash
docker compose --env-file .env up -d
```

- Compose가 자동으로 `default` 네트워크 생성 및 연결

## 개발 서버

### 단일 서비스 실행

```bash
docker compose \
  -f ../docker-compose.common.yml \
  -f docker-compose.yml \
  --env-file .env \
  up -d
```

- `docker-compose.common.yml`의 네트워크 설정이 병합되면서
- 서비스가 `msa-net`에 정상 연결됨

### 전체 서비스 실행 (`scripts/start-all.sh`)

```bash
#!/bin/bash
set -e

COMMON_COMPOSE_FILE="../docker-compose.common.yml"

echo "=== 전체 서비스 실행 시작 ==="

for SERVICE_DIR in ../*/ ; do
  if [[ -f "$SERVICE_DIR/docker-compose.yml" && -f "$SERVICE_DIR/.env" ]]; then
    echo "🚀 실행 중: $SERVICE_DIR"
    docker compose \
      -f "$COMMON_COMPOSE_FILE" \
      -f "$SERVICE_DIR/docker-compose.yml" \
      --env-file "$SERVICE_DIR/.env" \
      up -d
  fi
done

echo "✅ 전체 서비스 실행 완료"
```

- 자동으로 디렉토리를 하나씩 돌아가며 서비스 실행

### 전체 서비스 중지 (`scripts/stop-all.sh`)

```bash
#!/bin/bash
set -e

COMMON_COMPOSE_FILE="../docker-compose.common.yml"

echo "=== 전체 서비스 중지 시작 ==="

for SERVICE_DIR in ../*/ ; do
  if [[ -f "$SERVICE_DIR/docker-compose.yml" ]]; then
    echo "🛑 중지 중: $SERVICE_DIR"
    docker compose \
      -f "$COMMON_COMPOSE_FILE" \
      -f "$SERVICE_DIR/docker-compose.yml" \
      down
  fi
done

echo "✅ 전체 서비스 중지 완료"
```

- 자동으로 디렉토리를 하나씩 돌아가며 서비스 중지
