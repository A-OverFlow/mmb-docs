# CQRS (Command Query Responsibility Segregation)

---

## 1. 정의

CQRS는 Command(쓰기)와 Query(읽기)의 책임을 분리하는 설계 방식이다.

- **Command**: 시스템 상태를 변경하는 작업 (POST, PUT, DELETE)
- **Query**: 시스템 상태를 조회하는 작업 (GET)

---

## 2. CQRS를 도입하지 않은 전통적인 시스템의 구조와 문제점

### 🔧 구조

- 하나의 서비스/모델이 읽기와 쓰기를 모두 처리
- 단일 DB, 단일 테이블에 모든 책임 집중
- 예: `UserService`가 저장도 하고, 화면에 필요한 데이터도 그대로 조회함

### ⚠️ 문제점

| 문제       | 설명                                         |
|----------|--------------------------------------------|
| 책임 혼재    | 도메인 로직과 화면 전용 로직이 뒤섞임                      |
| 성능 병목    | 읽기 성능 튜닝이 쓰기 모델을 망가뜨릴 수 있음 (e.g. 복잡한 JOIN) |
| 유지보수 어려움 | 하나의 변경이 양쪽 로직에 영향                          |
| 확장성 부족   | 읽기 트래픽 폭증 시 전체 시스템 느려짐                     |
| 테스트 어려움  | 유닛 테스트/Mock 분리가 어려움                        |
| UX 제약    | 화면에 맞는 DTO/쿼리 모델이 따로 없어서 처리 어렵고 복잡함        |

👉 이 때문에 읽기/쓰기를 **역할에 맞게 분리**할 필요가 있다.

---

## 3. CQRS 구현 전략

### ✅ 명령과 조회를 구분하여 구현

### 구현 방법 1. 같은 프로세스, 같은 DB

- 단순한 형태
- 명령과 쿼리의 로직만 구분
- 동일한 테이블을 사용하므로 동기 일관성 확보 쉬움

### 구현 방법 2. 같은 프로세스, 다른 테이블

- 예: `posts` 테이블 외에 `hot_posts_view` 별도 유지
- 쿼리 전용 테이블은 조회에 최적화된 비정규화 구조 가능

### 구현 방법 3. 같은 프로세스, 다른 DB

- MySQL + MongoDB 같이 사용하는 구조
- 명령이 데이터를 변경하면 쿼리 DB도 갱신해야 함

### 구현 방법 4. 다른 프로세스, 다른 DB

- 완전한 마이크로서비스 구조
- 각각 독립적으로 배포, 유지보수 가능


---

## 4. 변경 전파 방식

| 방식 | 설명 | 장점 | 단점 |
|------|------|------|------|
| 직접 수정 | 명령 코드가 쿼리 DB도 직접 수정 | 단순 | 실패 시 유실 위험 |
| 이벤트 저장 후 전파기 | 트랜잭션 내에 변경내용 저장, 전파기가 처리 | 유실 방지, 신뢰성 ↑ | 전파기 필요 |
| CDC 활용 | DB의 변경 로그를 기반으로 반영 (Debezium 등) | 자동화 쉬움 | 기술 복잡도 ↑ |

---

## 5. 전파 시 고려사항

- ❗ **데이터 유실 가능성**  
  → 메시지 손실, 처리 실패 대비 필요

- ⏳ **허용 가능한 지연 시간**  
  → 쿼리 모델이 실제보다 0.5~2초 늦을 수 있음

- 🔁 **중복 전파 방지**  
  → Query 모델은 idempotent하게 처리 필요 (중복 저장해도 무해하게)

---

## 6. 언제 CQRS를 쓰는 게 좋은가?

| 적합한 상황 | 설명 |
|--------------|------|
| 읽기와 쓰기 요구사항이 매우 다를 때 | 예: SNS 조회 vs 글쓰기 |
| 조회 트래픽이 압도적으로 많을 때 | 캐시/NoSQL로 조회 분산 |
| 서비스가 점점 복잡해지는 경우 | 도메인 책임 분리, 유지보수 편해짐 |
| 이벤트 기반 구조로 확장하려는 경우 | CQRS는 이벤트 중심 아키텍처와 궁합 좋음 |

---

## 7. 실습 적용 계획 (채팅 서비스)

현재 운영 중인 채팅 서비스에 CQRS를 점진적으로 적용할 계획이다.  
WebSocket을 통한 메시지 전송이 Command 역할,  
REST API를 통한 채팅 메시지 조회가 Query 역할을 하고 있다는 점에서  
CQRS의 기본 구조는 이미 내포하고 있다.

---

### 🎯 실습 목표

- Command/Query 책임을 명확히 분리하여 구조 개선
- 유지보수성과 확장성 기반 마련

---

### 🛠️ 실습 범위 및 계획

#### 1. 패키지 분리

chat/  
├── command/  
│   ├── dto/  
│   ├── service/  
│   └── controller/  
├── query/  
│   ├── dto/  
│   ├── service/  
│   └── controller/  
├── domain/  
├── repository/

- `command`, `query` 폴더로 나누어 책임이 명확한 구조로 구분
- 각 계층(service/dto/controller)도 목적에 맞게 분리

#### 2. DTO 분리

| 용도 | 클래스 | 설명 |
|------|--------|------|
| Command | `SendChatMessageCommand` | WebSocket 수신 후 처리용 |
| Query   | `ChatMessageResponse`    | MongoDB 조회 결과 응답용 |

- 쓰기용 DTO와 조회용 DTO를 분리하여 각 책임에 맞는 필드만 포함

#### 3. 서비스 역할 분리

- `ChatCommandService`: 메시지 저장 + Redis 브로드캐스트 처리
- `ChatQueryService`: MongoDB로부터 채팅 히스토리 조회 전담

---

### ✅ 변경 요약

| 항목 | 변경 내용 |
|------|-----------|
| 📁 패키지 구조 | `command`, `query` 폴더로 분리 |
| 📦 DTO 분리 | Command/Query 목적에 따라 DTO 별도 관리 |
| 🧠 역할 분리 | WebSocket은 Command 흐름, REST API는 Query 흐름 담당 |

---

### 📌 기대 효과

- 테스트와 기능 개발 시 책임 명확화
- 조회와 저장의 변경 영향 분리
- CQRS 패턴 학습 및 적용 기반 마련
